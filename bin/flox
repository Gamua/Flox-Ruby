#!/usr/bin/env ruby

## Author:    Daniel Sperl
## Copyright: Copyright 2014 Gamua
## License:   Simplified BSD

require 'flox'
require 'fileutils'
require 'slop'

# Helper class that does the heavy lifting.
class Worker

  attr_reader :flox

  def initialize(args={})
    base_url = args[:url] || Flox::DEFAULT_URL
    game_id  = args[:game_id]
    game_key = args[:game_key]
    hero_key = args[:hero_key]

    @flox = Flox.new(game_id, game_key, base_url)
    print "Logging in as Hero ... "
    @flox.login_with_key hero_key
    puts "done."
  end

  def load_logs(args={})
    query = args[:query]
    limit = args[:limit]
    destination = args[:destination] || Dir.pwd
    FileUtils.mkdir_p(destination)

    print "Loading log IDs (this could take a moment) ... "
    log_ids = flox.load_log_ids(query, limit)
    puts "found #{log_ids.length} logs."
    log_ids.each do |log_id|
      remote_path = "logs/#{log_id}"
      local_path = File.join(destination, log_id) + ".json"
      load_and_save_resource(remote_path, local_path)
    end
  end

  private

  def load_and_save_resource(remote_path, local_path)
    if (File.exists? local_path)
      puts("Skipped #{local_path} (file exists)")
    else
      resource = flox.load_resource(remote_path)
      File.write(local_path, JSON.pretty_generate(resource))
      puts("Saved #{local_path}")
    end
  end

end

#
# Parsing command line arguments
#

def shared_options
  on :i, "game_id=", "The public identifier of the game", :required => true
  on :k, "game_key=", "The private key of the game", :required => true
  on :o, "hero_key=", "The key of a Hero player that will be logged in", :required => true
  on :u, "url=", "The URL to the Flox service"
end

begin

  ARGV << "-h" if ARGV.empty?
  Slop.parse(ARGV, :help => true) do

    on :v, "version", 'Print the current version of the Flox Gem.' do
      puts "Gamua Flox v#{Flox::VERSION}"
    end

    command "load_logs" do
      description "Fetch log files from the server."

      shared_options
      on :d, "destination=", "The directory in which to store the logs"
      on :q, "query=", "Narrow down the results, e.g. 'day:2013-12-24 severity:error'"
      on :l, "limit=", "Maximum number of logs to download", as: Integer

      run do |opts, args|
        Worker.new(opts).load_logs(opts)
      end
    end

  end

rescue Slop::Error, Flox::Error => error
  puts error
end
